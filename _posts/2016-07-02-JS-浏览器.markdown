---
layout: post
title:  "JS浏览器"
date:   2016-07-02 08:45:59
author: zhanggeng
categories: JavaScript
---

不同的浏览器对JS支持的差异主要是，有些API接口不一样，比如：AJAX，File接口。对于ES6标准，不同的浏览器对各个特性支持也不一样。

在编写JS的时候，要充分考虑浏览器的差异，尽量让同一份JS代码能运行在不同浏览器中。


# 浏览器对象

## window

window对象不但充当全局作用域，而且表示浏览器窗口。

window对象有innerWidth 和 innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。

```
console.log('window inner size is : ' + window.innerWidth + '=====' + window.innerHeight);
```

对应的获取浏览器窗口的整个宽高：

```
console.log('window outer size is : ' + window.outerWidth + '=====' + window.outerHeight);
```

## navigator

navigator对象表示浏览器的信息，最常用的属性包括：

* navigator.appName：浏览器名称；
* navigator.appVersion：浏览器版本；
* navigator.language：浏览器设置的语言；
* navigator.platform：操作系统类型；
* navigator.userAgent：浏览器设定的User-Agent字符串。

```
console.log('appName = ' + navigator.appName + '\n' +
    'appVersion = ' + navigator.appVersion + '\n' +
    'language = ' + navigator.language + '\n' +
    'platform = ' + navigator.platform + '\n' +
    'userAgent = ' + navigator.userAgent);
```

## screen

screen对象表示屏幕的信息，常用的属性有：

* screen.width：屏幕宽度，以像素为单位；
* screen.height：屏幕高度，以像素为单位；
* screen.colorDepth：返回颜色位数，如8、16、24。

```
console.log('Screen size = ' + screen.width + ' x ' + screen.height + '=====' + screen.colorDepth);
```

## location

location对象表示当前页面的URL信息。

```
http://www.example.com:8080/path/index.html?a=1&b=2#TOP
```

可以用location.href获取。要获得URL各个部分的值，可以这么写：

```
location.protocol; // 'http'
location.host; // 'www.example.com'
location.port; // '8080'
location.pathname; // '/path/index.html'
location.search; // '?a=1&b=2'
location.hash; // 'TOP'
```

要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。

```
if (confirm('重新加载当前页' + location.href + '?')) {
    location.reload();
} else {
    location.assign('/discuss'); // 设置一个新的URL地址
}
```

## document

document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。

document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变：

```
document.title = '努力学习JavaScript!';
```

要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。

document 对象还有一个cookie属性，可以获取当前页面的Cookie。

JS可以通过document.cookie读取到当前页面的Cookie：

```
document.cookie
```

为了防止第三方JS代码恶意获取cookie，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。


## history

history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。

这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。

新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。

任何情况，你都不应该使用history这个对象了。(好，但是新的解决方案是什么？)

## 操作DOM

HTML文档被解析后是一颗DOM树，要改变HTML结构，就要通过JS来操作DOM树。

操作一个DOM节点实际上就是这么几个动作：

* 更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；
* 遍历：遍历该DOM节点下的子节点，以便进行进一步操作；
* 添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；
* 删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。

获取某个DOM节点：

```
document.getElementById();直接定位唯一的一个DOM节点
document.getElementsByTagName();返回一组DOM节点
document.getElementsByClassName();返回一组DOM节点
```

```
<!-- HTML结构 -->
<div id="test-div">
<div class="c-red">
    <p id="test-p">JavaScript</p>
    <p>Java</p>
  </div>
  <div class="c-red c-green">
    <p>Python</p>
    <p>Ruby</p>
    <p>Swift</p>
  </div>
  <div class="c-green">
    <p>Scheme</p>
    <p>Haskell</p>
  </div>
</div>
```

```
// 选择<p>JavaScript</p>:
var js = document.getElementById('test-p');

// 选择<p>Python</p>,<p>Ruby</p>,<p>Swift</p>:
var arr = document.getElementsByClassName('c-red c-green')[0].children;

// 选择<p>Haskell</p>:
var haskell = document.getElementsByClassName('c-green')[1]. lastElementChild;
```


### 更新DOM

拿到一个DOM节点后，我们可以对它进行更新。

方式一：修改`innerHTML`属性，该方法，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点的内部子树：

```
// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置文本为abc:
p.innerHTML = 'ABC'; // <p id="p-id">ABC</p>
// 设置HTML:
p.innerHTML = 'ABC <span style="color:red">RED</span> XYZ';
// <p>...</p>的内部结构已修改
```

// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置文本为abc:
p.innerHTML = 'ABC'; // <p id="p-id">ABC</p>
// 设置HTML:
p.innerHTML = 'ABC <span style="color:red">RED</span> XYZ';
// <p>...</p>的内部结构已修改

方式二：修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签：

```
// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置文本:
p.innerText = '<script>alert("Hi")</script>';
// HTML被自动编码，无法设置一个<script>节点:
// <p id="p-id">&lt;script&gt;alert("Hi")&lt;/script&gt;</p>
```

innerText和textContent的区别：

* innerText不返回隐藏元素的文本
* textContent返回所有文本（IE<9不支持textContent）

经常需要修改CSS，DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的属性，但是它在JS中不是有效的属性名，所以在JS中需要改写为驼峰式的命名fontSize:

```
// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置CSS:
p.style.color = '#ff0000';
p.style.fontSize = '20px';
p.style.paddingTop = '2em';
```


*practice*

```
<!-- HTML结构 -->
<div id="test-div">
  <p id="test-js">javascript</p>
  <p>Java</p>
</div>
```

尝试获取指定节点并修改：

```
// 获取<p>javascript</p>节点:
var js = document.getElementById('test-js');

// 修改文本为JavaScript:
// TODO:
js.innerHTML = 'JavaScript';

// 修改CSS为: color: #ff0000, font-weight: bold
// TODO:


js.style.color = '#ff0000';
js.style.fontWeight = 'bold';
```

### 插入DOM

当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，该咋办？

#### 如果该DOM节点是空的：

如：<div></div>，那么直接使用`innerHTML = '<span>child</span>'` 就可以修改DOM节点的内容，相当于'插入'了新的DOM节点；

#### 如果该DOM节点不是空的：

那就不能这么干了，因为innerHTML会直接替换掉原来的所有子节点。

有两个办法可以插入新节点：

* 一是使用appendChild，把一个子节点添加到父节点的最后一个子节点。

```
var
    js = document.getElementById('js'),
    list = document.getElementById('list');
list.appendChild(js);
```
因为插入的JS节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。

* 从零创建一个新的节点，然后插入到指定位置：

```
var
    list = document.getElementById('list'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.appendChild(haskell);
```

#### insertBefore

`parentElement.insertBefore(newElement,referenceElement);`，会把子节点插入到referenceElement之前。

```
<!-- HTML结构 -->
<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
</div>
```

```
var
    list = document.getElementById('list'),
    ref = document.getElementById('python'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.insertBefore(haskell, ref);
```

如何循环一个父节点的所有子节点？可以通过迭代children属性实现：

```
var
    i, c,
    list = document.getElementById('list');
for (i = 0; i < list.children.length; i++) {
    c = list.children[i]; // 拿到第i个子节点
}
```


### 删除DOM

要删除一个DOM节点，首先要获得该节点本身以及它的父亲点，然后，调用父节点的removeChild把自己删掉：

```
// 拿到待删除节点:
var self = document.getElementById('to-be-removed');
// 拿到父节点:
var parent = self.parentElement;
// 删除:
var removed = parent.removeChild(self);
removed === self; // true
```

当你遍历一个父亲点的子节点进行删除的时候，注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。

## 操作表单

JS用来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。

HTML表单的输入控件主要有以下几种：

* 文本框，对应的<input type="text">，用于输入文本；
* 口令框，对应的<input type="password">，用于输入口令；
* 单选框，对应的<input type="radio">，用于选择一项；
* 复选框，对应的<input type="checkbox">，用于选择多项；
* 下拉框，对应的<select>，用于选择一项；
* 隐藏文本，对应的<input type="hidden">，用户不可见，但表单提交时会把隐藏文本发送到服务器。

### 获取值

如果我们获得了一个<input>节点的引用，就可以直接调用value获得对应的用户输入值：

```
// <input type="text" id="email">
var input = document.getElementById('email');
input.value; // '用户输入的值'
```

可以用这种方式获取：text、password、hidden、select的值。

对于单选框和复选框，value属性返回的是HTML预设的值，而我们需要的是用户‘勾上’的选项，因此要用`checked`来判断：

```
// <label><input type="radio" name="weekday" id="monday" value="1"> Monday</label>
// <label><input type="radio" name="weekday" id="tuesday" value="2"> Tuesday</label>
var mon = document.getElementById('monday');
var tue = document.getElementById('tuesday');
mon.value; // '1'
tue.value; // '2'
mon.checked; // true或者false
tue.checked; // true或者false
```

### 设置值

对于text、password、hidden、selector，直接设置value就可以：

```
// <input type="text" id="email">
var input = document.getElementById('email');
input.value = 'test@example.com'; // 文本框的内容已更新
```

对于单选框和复选框，设置checked为true或false即可。

### HTML5控件

H5新增了大量标准控件，常用的包括 date、datetime、datetime-local、color等，他们都是用<input>标签：

```
<input type="date" value="2015-07-01">

<input type="datetime-local" value="2015-07-01T02:03:04">

<input type="color" value="#ff0000">
```

### 提交表单

JS可以以两种方式来处理表单的提交。

方式一：通过<form>元素的submit()方法提交一个表单，例如，响应一个<button>的click时间，在JS中提交表单：

```
<!-- HTML -->
<form id="test-form">
    <input type="text" name="test">
    <button type="button" onclick="doSubmitForm()">Submit</button>
</form>

<script>
function doSubmitForm() {
    var form = document.getElementById('test-form');
    // 可以在此修改form的input...
    // 提交form:
    form.submit();
}
</script>
```

## 操作文件

在HTML表单中，可以上传文件的唯一控件是<input type='file'>.

*Notice：*当一个表单包含<input type="file">时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。

浏览器只允许用户点击<input type='file'>来选择本地文件，用JS对<input type='file'>的value赋值是没有任何效果的。当用户选择了上传某个文件后，JS也无法获得该文件的真实路径。


### File API:

H5中，新增的File API允许JS读取文件内容，获得更多的文件信息。

H5的File API提供了File 和 FileReader两个主要对象，可以获得文件信息并读取文件。

### 回调

单线程执行模式是JS的一个重要特性。在JS中，浏览器的JS执行引擎在执行JS代码时，总是以单线程模式执行，也就是说，任何时候，Js代码都不可能同时多于1个线程执行。

单线程模式执行的JS，如何处理多任务？

在JS中，执行多任务实际都是用异步调用，因此需要设置一个回调函数，当文件读取文成后，JS引擎将自动调用我们设置的回调函数。

## AJAX

AJAX是什么？

AJAX不是JS的规范，是一个哥们发明的缩写:Asynchronous JavaScript and XML，意思是用JS执行异步网络请求。

在一个Form表单中，用户点击‘Submit’按钮后，表单开始提交，浏览器就会刷新页面，如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JS发送这个新请求，接收到数据后，再用JS更新页面，这样用户就可以感觉到自己停留在当前页面，但是数据却在不断的更新。


AJAX是干嘛的？

AJAX就是用JS执行异步网络请求。


如何使用AJAX：

在现代浏览器上使用：

```
function success(text) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = 'Error code: ' + code;
}

var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象

request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open('GET', '/api/categories');
request.send();

alert('请求已发送，请等待响应...');

```

在低版本IE上使用：需要使用ActiveXObject对象：

```
function success(text) {
    var textarea = document.getElementById('test-ie-response-text');
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById('test-ie-response-text');
    textarea.value = 'Error code: ' + code;
}

var request = new ActiveXObject('Microsoft.XMLHTTP'); // 新建Microsoft.XMLHTTP对象

request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open('GET', '/api/categories');
request.send();

alert('请求已发送，请等待响应...');

```

如果想把标准写法和IE写法写在一起，可以这样：

```
var request;
if (window.XMLHttpRequest) {
    request = new XMLHttpRequest();
} else {
    request = new ActiveXObject('Microsoft.XMLHTTP');
}

```

上述代码中：

* 通过window.XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。
* 当创建了XMLHttpRequest对象后，要先这只onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。
* XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。
* 调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 


### 安全限制

浏览器同源策略(参考[浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html))


### CORS

[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

## Promise

在JS的世界中，所有代码都是单线程执行的。 

在JS中“承诺将来会执行”的对象在JS中被称为Promise对象。

```
var ajax = ajaxGet('http://...');
ajax.ifSuccess(success)
    .ifFail(fail);
```

Promise有各种开源实现，在ES6中被统一规范，由浏览器支持。

Promise 最大的好处是在异步执行的六层中，把执行代码和处理结果的代码清晰的分离了。 

如果要两个任务并行执行，可以用Promise.all()实现：

```
var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, 'P1');
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, 'P2');
});
// 同时执行p1和p2，并在它们都完成后执行then:
Promise.all([p1, p2]).then(function (results) {
    console.log(results); // 获得一个Array: ['P1', 'P2']
});
```

`Promise.race()`：有时候，多个异步任务为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。

```
var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, 'P1');
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, 'P2');
});
Promise.race([p1, p2]).then(function (result) {
    console.log(result); // 'P1'
});
```

## Canvas:

Canvas是H5的新组建，它像一块画布，可以用JS在上面绘制各种图表、动画。

一个Canvas定义一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：

```
<canvas id="test-canvas" width="300" height="200"></canvas>
```

由于浏览器对H5标准支持不一致，因此，通常在<canvas>内部添加一些说明性HTML代码，如果浏览器支持<canvas>属性，它将忽略<canvas>内部的HTML属性，如果浏览器不支持<canvas>，它将显示<canvas>内部的HTML：

```
<canvas id="test-stock" width="300" height="200">
    <p>Current Price: 25.51</p>
</canvas>
```

在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas：

```
var canvas = document.getElementById('test-canvas');
if (canvas.getContext) {
    alert('你的浏览器支持Canvas!');
} else {
    alert('你的浏览器不支持Canvas!');
}
```

getContext('2d')方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。

```
var ctx = canvas.getContext('2d');
```

绘制3D怎办？H5有一个WebGL规范，允许在Canvas中绘制3D图形：

g1 = canvas.getContext('webgl');

### 绘制形状

Canvas坐标系统：Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。

CanvasRenderingContext2D 有很多方法来绘制图形：

```
var
    canvas = document.getElementById('test-shape-canvas'),
    ctx = canvas.getContext('2d');
    
ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
ctx.fillStyle = '#dddddd'; // 设置颜色
ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色
// 利用Path绘制复杂路径:
var path=new Path2D();
path.arc(75, 75, 50, 0, Math.PI*2, true);
path.moveTo(110,75);
path.arc(75, 75, 35, 0, Math.PI, false);
path.moveTo(65, 65);
path.arc(60, 65, 5, 0, Math.PI*2, true);
path.moveTo(95, 65);
path.arc(90, 65, 5, 0, Math.PI*2, true);
ctx.strokeStyle = '#0000ff';
ctx.stroke(path);

```
### 绘制文本

绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致。

```
var
    canvas = document.getElementById('test-text-canvas'),
    ctx = canvas.getContext('2d');
    
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.shadowOffsetX = 5;
ctx.shadowOffsetY = 8;
ctx.shadowBlur = 2;
ctx.shadowColor = '#666666';
ctx.font = '24px Arial';
ctx.fillStyle = '#333333';
ctx.fillText('带阴影的文字', 20, 40);

```

Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，可以使用如下优化方案：

* 通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；
* 尽量使用整数坐标而不是浮点数；
* 可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；
* 背景图片如果不变可以直接用<img>标签并放到最底层。



---
layout: post
title:  "JS面向对象编程"
date:   2016-06-28 08:45:59
author: zhanggeng
categories: JavaScript
---

在Java中，面向对象离不开两个实例：

1. 类：类是对象的类型模板；
2. 实例：实例是根据类创建的对象；

在JS中，不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。

JS的原型链和Java的Class区别就在，它没有‘Class’的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。

Object.create()方法可以传入一个原型对象，并创建一个机遇该原型的对象，但新对象什么属性都没有。

# 创建对象

JS对每个创建的对象都会设置一个原型，指向它的原型对象。

当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。

## 构造函数

除了直接用{...}创建一个对象外，JS 还可以用构造函数的方法来创建对象。用法，先定义一个构造函数：

```
function Student(name) {
    this.name = name;
    this.hello = function () {
        alert('Hello, ' + this.name + '!');
    }
}
```

```
var xiaoming = new Student('小明');
xiaoming.name; // '小明'
xiaoming.hello(); // Hello, 小明!
```

Notice: 

> 如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;

忘记写new怎么办？

在strict模式下，this.name = name将报错，因为this绑定为undefined，在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕。

因此，千万不能忘记写new。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写。


# 原型继承

Java中继承的本质：扩展一个已有的Class，并生成新的Subclass。

JS采用原型链继承，无法直接扩展一个Class，因为根本不存在Class这种类型。

JS的继承如此麻烦啊。。。。。。无语：

JS的原型继承实现方式就是：

1. 定义新的构造函数，并在内部用call()调用希望‘继承’的构造函数，并绑定this;
2. 借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；
3. 继续在新的构造函数的原型上定义新的方法。 

```
function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}
```

```
function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}
```

```
function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};
```

# class 继承

ES6引入的class关键字，让定义类更简单。

ES6中JS定义一个类：

```
class Student {
    constructor(name) {
        this.name = name;
    }

    hello() {
        alert('Hello, ' + this.name + '!');
    }
}
```

```
var xiaoming = new Student('小明');
xiaoming.hello();
```

ES6中类的继承：

```
class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert('I am at grade ' + this.grade);
    }
}
```

这个要原型链那种方式简单很多！



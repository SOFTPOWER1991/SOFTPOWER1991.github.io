---
layout: post
title:  "JS快速入门"
date:   2016-06-20 08:45:59
author: zhanggeng
categories: JavaScript
---

# 快速入门

1. JS代码应该放在什么位置呢？

	* JS代码可以嵌在网页的任何地方，通常我们都把JS代码放到<head>中：

		```
				<html>
				<head>
				  <script>
				    ......
				  </script>
				</head>
				<body>
				  ...
				</body>
				</html>
		```

	* 把JS代码放到一个单独的.js文件中，这样利于维护，并且在多个页面可以各自引用同一份.js文件。

		```
				<html>
				<head>
				  <script src="/static/js/abc.js"></script>
				</head>
				<body>
				  ...
				</body>
				</html>
		```

2. 在同一页面中引入多个.js文件后，还可以在页面中多次编写`<script> js代码... </script>`代码，浏览器将会按照顺序依次执行这些JS代码。
3. `<script>` 标签的type属性，不必显式声明，因为默认的`type`就是JavaScript.


# 基本语法

* JS语法：每个语句以`;`结束，语句块用`{...}`。
* 行注释：
	
```
// 这是一行注释
alert('hello'); // 这也是注释
```

* 块注释：

```
/* 从这里开始是块注释
仍然是注释
仍然是注释
注释结束 */
```

# 数据类型、变量、strict模式

JS中的数据类型有：Number、字符串、布尔值、null和undefined、数组、对象。


* *Number* : JS不区分整数和浮点数，统一用Number表示。
	
```
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示		1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```
> 需要注意的是：NaN这个特殊的Number与其他值都不相等，包括它自己。唯一能判断NaN的方法是通过isNaN()函数来判断： isNaN(NaN)。
	
*  *字符串:* 字符串是以单引号 '' 或者 双引号 "" 括起来的任意文本。
*  *布尔值:* true 、false
*  *null和undefined:* null表示一个“空”的值，它和`0`以及空字符串不同。undefined表示为定义。大多数情况下，我们都应该用null,undefined仅仅在判断函数参数是否传递的情况下有用。

* *strict模式:*：不用var申明的变量就会被视为全局变量！ECMA推出的strict模式，是为了弥补JS的一个var申明的缺陷，在该模式下JS代码，强制通过var申明变量，未使用var申明变量就是用的， 将导致运行错误。 
	
那么该如何启动strict模式呢？在JS代码的第一行写上下面的代码：
	
```
'use strict';
```

* *变量:* JS中变量名的命名规则：变量名是大小写英文、数字、$ 和 _ 的组合，且不能用数字开头。变量名也不能是JS的关键字。


# 比较运算符

== , === , < , <= , > , >= 
 
== 和 ===的区别：

* == 会自动转换数据类型再比较，很多时候，会得到诡异的结果；
* === 不会自动转换数据类型，数据类型不一致，返回false,如果一致，再比较。
* 由于这个设计缺陷，不要用==比较，始终用===比较。 
 
# 字符串

JS中字符串如何表示:

> 用 '' 或者 ""括起来的字符表示。

如果字符串内部既包含`'`又包含`"`怎么办？

> 用转义字符 `\`进行标识。

怎么让字符串换行？

> 1. 使用 `\n`;
> 2. ES6标准新增了一种多行字符串的表示方法，用\`...\`表示：

```
`这是一个
多行
字符串`;
```

字符串的常见操作：

* *toUpperCase* : 把一个字符串全部变为大写：

```
var s = 'Hello';
s.toUpperCase(); // 返回'HELLO'
```
* *toLowerCase* : 把一个字符串全部变为小写：
	
```
var s = 'Hello';
var lower = s.toLowerCase(); // 返	回'hello'并赋值给变量lower
lower; // 'hello'
```
* *indexOf* : 会搜索指定字符串出现的位置：

```
var s = 'hello, world';
s.indexOf('world'); // 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
```
* *substring* : 返回指定索引区间的子串：

```
var s = 'hello, world'
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

# 数组

1. JS中如何创建一个数组？

	* 用`[]`括起来，元素之间用`，`分割，这个和Java一样。
	
	```
	[1, 2, 3.14, 'Hello', null, true];
	```
	
	* 通过new Array()函数实现，跟Java差不多：
	
	```
	new Array(1, 2, 3); // 创建了数组[1, 2, 3]
	```
	
		> 出于代码的可读性，建议直接使用`[]`

2. JS中数组的特点？

	* JS的array可以包含任意数据类型，并通过索引来访问每个元素。
	
	```
	var arr = [1, 2, 3.14, 'Hello', null, true];
	```
	
	* length 属性： arr.length 可以获取数组的长度，需要注意的是，给Array的length赋一个新的值会导致Array的大小变化：
	
	```
	var arr = [1, 2, 3];
	arr.length; // 3
	arr.length = 6;
	arr; // arr变为[1, 2, 3, undefined, 	undefined, undefined]
	arr.length = 2;
	arr; // arr变为[1, 2]
	```
	
	* 可以通过索引把对应的元素修改为新值，对Array的索引进行赋值操作会直接修改这个Array：
	
	```
	var arr = ['A', 'B', 'C'];
	arr[1] = 99;
	arr; // arr现在变为['A', 99, 'C']
	```
	
	* 通过索引赋值，索引超过了范围，同样会引起array大小变化：
		
	```
	var arr = [1, 2, 3];
	arr[5] = 'x';
	arr; // arr变为[1, 2, 3, undefined, 	undefined, 'x']
	```
	 
	> 最后一个特点，让我感觉有点不可思议，在Java中数组越界直接抛出数组越界异常，在JS中竟然会修改Array长度。廖老师如是说：在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。
 
3. JS中对数组的常用操作：

	* indexOf： Array也可以通过indexOf()来搜索一个指定的元素的位置
		
	```
	var arr = [10, 20, '30', 'xyz'];
	arr.indexOf(10); // 元素10的索引为0
	arr.indexOf(20); // 元素20的索引为1
	arr.indexOf(30); // 元素30没有找到，返回-1
	arr.indexOf('30'); // 元素'30'的索引为2
	```
	
	* slice:它截取Array的部分元素，然后返回一个新的Array
	
		```
		var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
		arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
		arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
		```
		
		> Notice: slice()的起止参数包括开始索引，不包括结束索引。
	
	如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array：
	
	```
	var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
	var aCopy = arr.slice();
	aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
	aCopy === arr; // false
	```
	
	> Notice: slice()不会改变原数组
	
	* push 和 pop：push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：
	
		```
		var arr = [1, 2];
		arr.push('A', 'B'); // 返回Array新的长度: 4
		arr; // [1, 2, 'A', 'B']
		arr.pop(); // pop()返回'B'
		arr; // [1, 2, 'A']
		arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
		arr; // []
		arr.pop(); // 空数组继续pop不会报错，而是返回undefined
		arr; // []
		```
	* unshift 和 shift：如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：
	
		```
		var arr = [1, 2];
		arr.unshift('A', 'B'); // 返回Array新的长度: 4
		arr; // ['A', 'B', 1, 2]
		arr.shift(); // 'A'
		arr; // ['B', 1, 2]
		arr.shift(); 
		arr.shift(); 	
		arr.shift(); // 连续shift 3次
		arr; // []
		arr.shift(); // 空数组继续shift不会报错，而是返回undefined
		arr; // []
		```
	* sort：sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序
		
		```
		var arr = ['B', 'C', 'A'];
		arr.sort();
		arr; // ['A', 'B', 'C']
		```
	* reverse: 把整个Array的元素给掉个个，也就是反转：
		```
		var arr = ['one', 'two', 'three'];
		arr.reverse(); 
		arr; // ['three', 'two', 'one']
		```
	* splice:它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素:
		```
			var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
			// 从索引2开始删除3个元素,然后再添加两个元素:
			arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
			arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
			// 只删除,不添加:
			arr.splice(2, 2); // ['Google', 'Facebook']
			arr; // ['Microsoft', 'Apple', 'Oracle']
			// 只添加,不删除:
			arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
			arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
		```
	* concat:当前的Array和另一个Array连接起来，并返回一个新的Array：
		
		```
		var arr = ['A', 'B', 'C'];
		var added = arr.concat([1, 2, 3]);
		added; // ['A', 'B', 'C', 1, 2, 3]
		arr; // ['A', 'B', 'C']
		```
		
		> 1. concat()方法并没有修改当前Array，而是返回了一个新的Array。
		> 2. concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：
		
		```
		var arr = ['A', 'B', 'C'];
		arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
		```
		
	* join:把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。如果Array的元素不是字符串，将自动转换为字符串后再连接。
		
		```
		var arr = ['A', 'B', 'C', 1, 2, 3];
		arr.join('-'); // 'A-B-C-1-2-3'
		```

4. 多维数组：如果数组的某个元素又是一个Array，则可以形成多维数组。

	```
	var arr = [[1, 2, 3], [400, 500, 600], '-'];
	```


# 对象

如何定义一个JavaScript对象？

JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用`,`隔开。注意，最后一个键值对不需要在末尾加。JS中的对象是一种无序的集合数据类型，它由若干键值对组成。

```
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
```

如何访问JS对象的属性呢？

访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。

```
xiaoming.name; // '小明'
xiaoming.birth; // 1990
```

如果访问一个不存在的JS属性会怎样呢？JS规定，访问不存在的属性不报错，而是返回

`undefined`：

```
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
```

JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：

```
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
```

如何判断一个对象是否具有某个属性呢？

使用`in`操作符。

```
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```

*坑*： 如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的。

```
'toString' in xiaoming; // true
```
因为`toString`定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。

那么，如何判断一个属性是否是某个对象自身拥有的，而不是继承得到的？

用 `hasOwnProperty()`方法

```
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```


# 条件判断

JavaScript使用if () { ... } else { ... }来进行条件判断。

*坑*：如果if的条件判断语句结果不是true或false怎么办？

```
var s = '123';
if (s.length) { // 条件计算结果为3
    //
}
```

JS 把`null` , `undefined`,`0` , `NaN` 和空字符串'' 视为false,其它值一概为true,因此上述代码条件判断的结果是true。

# 循环

#### for循环

* 一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块：

```
var x = 0;
var i;
for (i=1; i<=10000; i++) {
    x = x + i;
}
x; // 50005000
```

* for循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来：

```
var o = {
    name: 'Jack',
    age: 20,
    city: 'Beijing'
};
for (var key in o) {
    alert(key); // 'name', 'age', 'city'
}
```

*坑*：for ... in对Array的循环得到的是String而不是Number。

#### while

`while`循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。

```
var x = 0;
var n = 99;
while (n > 0) {
    x = x + n;
    n = n - 2;
}
x; // 2500
```
在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。

#### do ... while

do { ... } while()循环，它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件：

```
var n = 0;
do {
    n = n + 1;
} while (n < 100);
n; // 100
```

# Map和Set

`Map`和`Set`是ES6标准新增的数据类型，根据浏览器的支持情况决定是否要使用。

#### Map

`Map`是一组键值对的结构，具有极快的查找速度。

在JS中初始化`Map`: 需要一个二维数组，或者直接初始化一个空Map。

```
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

Map有如下操作方法：

```
var m = new Map(); // 空Map
m.set('Adam', 67); // 添加新的key-value
m.set('Bob', 59);
m.has('Adam'); // 是否存在key 'Adam': true
m.get('Adam'); // 67
m.delete('Adam'); // 删除key 'Adam'
m.get('Adam'); // undefined
```

*Notice:* 多次对一个key放入value，后面的值会把前面的值冲掉

#### Set

Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。

JS中如何创建Set?

要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set

```
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
```

Set的常用操作方法：

* add(key):可以添加元素到Set中，可以重复添加，但不会有效果

```
>>> s.add(4)
>>> s
{1, 2, 3, 4}
>>> s.add(4)
>>> s
{1, 2, 3, 4}
```
 
* delete(key):方法可以删除元素

```
var s = new Set([1, 2, 3]);
s; // Set {1, 2, 3}
s.delete(3);
s; // Set {1, 2}
```

# iterable

遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。

ES6引入了新的iterable类型，来统一集合类型：Array、Map 和 Set都属于iterable类型。

具有iterable类型的集合可以通过新的`for ... of`循环来遍历。

*for ... of循环是ES6引入的新的语法*

用`for ... of`循环遍历集合：

```
var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    alert(x);
}
for (var x of s) { // 遍历Set
    alert(x);
}
for (var x of m) { // 遍历Map
    alert(x[0] + '=' + x[1]);
}
```

`for...in` 和 `for...of`有啥区别？

* for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称
* 环则完全修复了这些问题，它只循环集合本身的元素

然而，更好的迭代方式是使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。

```
var a = ['A', 'B', 'C'];
a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
    alert(element);
});
```

*forEach()方法是ES5.1标准引入的，你需要测试浏览器是否支持*

Set的迭代：

```
var s = new Set(['A', 'B', 'C']);
s.forEach(function (element, sameElement, set) {
    alert(element);
});
```

Map的迭代：

```
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
m.forEach(function (value, key, map) {
    alert(value);
});
```




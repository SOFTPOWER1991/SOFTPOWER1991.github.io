---
layout: post
title:  "JS标准对象"
date:   2016-06-27 08:45:59
author: zhanggeng
categories: JavaScript
---

# 标准对象

在JS的世界里，一切都是对象。用`typeof`操作符获取对象的类型:

```
typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object'
typeof []; // 'object'
typeof {}; // 'object'
```

在上面的例子中有number、string、boolean、function、和undefined，他们有别于其他类型。null和Array都是object，使用typeof将无法区分出null、Array和通常意义的object——{}。

## 包装对象

JS中的包装对象用new创建：

```
var n = new Number(123); // 123,生成了新的包装类型
var b = new Boolean(true); // true,生成了新的包装类型
var s = new String('str'); // 'str',生成了新的包装类型
```

虽然包装对象看上去和原来的值一模一样，但他们的类型已经变味object了！因此用`===`比较会返回false：

```
typeof new Number(123); // 'object'
new Number(123) === 123; // false

typeof new Boolean(true); // 'object'
new Boolean(true) === true; // false

typeof new String('str'); // 'object'
new String('str') === 'str'; // false
```

如果在使用`Number`、`Boolean`、`String`时，没有写`new`会发生什么情况？

> 此时，Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）

```
var n = Number('123'); // 123，相当于parseInt()或parseFloat()
typeof n; // 'number'

var b = Boolean('true'); // true
typeof b; // 'boolean'

var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！
var b3 = Boolean(''); // false

var s = String(123.45); // '123.45'
typeof s; // 'string'
```

有下面几条规则需要遵守：

* 不要使用new Number()、new Boolean()、new String()创建包装对象；
* 用parseInt()或parseFloat()来转换任意类型到number；
* 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；
* 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}；
* typeof操作符可以判断出number、boolean、string、function和undefined；
* 判断Array要使用Array.isArray(arr)；
* 判断null请使用myVar === null；
* 判断某个全局变量是否存在用typeof window.myVar === 'undefined'；
* 函数内部判断某个变量是否存在用typeof myVar === 'undefined'。
* null和undefined 没有toString()方法，尽管null是object。


number对象调用toString()方法要做特殊处理：

```
123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
```

# Date

JS中，Date对象用来表示日期和时间。

要获取系统当前时间，用：

```
var now = new Date();
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳

```

*时间戳*：

时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。

*请绕坑*：

JS的月份范围用整数0~11表示，0表示一月，1表示二月。。。。。。依次类推！

如何创建一个指定日期和时间的Date对象？

第一种方式:

```
var d = new Date(2015, 5, 19, 20, 15, 30, 123);
d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)
```

第二种：创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：

```
var d = Date.parse('2015-06-24T19:49:22.875+08:00');
d; // 1435146562875
```

但它返回的不是Date对象，而是一个时间戳。利用时间戳，可以转换为一个Date:

```
var d = new Date(1435146562875);
d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
```

### 时区

Date对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间：

```
var d = new Date(1435146562875);
d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关
d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时
```


# RegExp

* 正则表达式中，如果直接给出字符，就是精确匹配；
* \d 可以匹配一个数字；
* \w 可以匹配一个字母或数字；
* . 可以匹配任意字符（只能匹配一个）
* * 表示任意字符（包括0个）
* + 表示至少一个字符；
* ？ 表示0个或1个字符
* {n} 表示n个字符；
* {n , m} 表示n-m个字符；
* 要做更精确的匹配，可以用[]表示范围；
* A|B 可以匹配A或B；
* ^ 表示行的开头： ^\d 表示必须以数字开头；
* `$` 表示行的结束： \d$ 表示必须以数字结束

JS中创建正则表达式的方式：

第一种方式：直接用/正则表达式/写出来；
第二种方式：通过 new RegExp('正则表达式')创建一个RegExp对象。

```
var re1 = /ABC\-001/;
var re2 = new RegExp('ABC\\-001');

re1; // /ABC\-001/
re2; // /ABC\-001/
```

RegExp对象使用test()方法来测试给定的字符串是否符合条件。

#### 切分字符串

使用split()方法进行切分；

#### 分组

JS中用（） 表示的就是要提取的分组。

在RegExp对象上用exec()方法提取出子串来；

* exec() 匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串；
* exec() 匹配失败时返回null。

#### 贪婪匹配

正则表达式默认是贪婪匹配的，也就是匹配尽可能多的字符。

？可以让 正则表达式采取非贪婪匹配。

#### 全局搜索

* g 表示全局匹配；
* i 表示忽略大小写；
* m 表示执行多行匹配；

```
var r1 = /test/g;
// 等价于:
var r2 = new RegExp('test', 'g');
```



# JSON

JSON的数据类型：

* number：和JavaScript的number完全一致；
* boolean：就是JavaScript的true或false；
* string：就是JavaScript的string；
* null：就是JavaScript的null；
* array：就是JavaScript的Array表示方式——[]；
* object：就是JavaScript的{ ... }表示方式。

JSON.stringify(xiaoming);

JSON.stringify(xiaoming, null, '  ');加入参数，按缩进输出；

第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array:

JSON.stringify(xiaoming, ['name', 'skills'], '  ');

反序列化：用JSON.parse()把它变成一个JavaScript对象：

```
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```



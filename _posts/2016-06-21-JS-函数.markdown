---
layout: post
title:  "JS函数"
date:   2016-06-21 08:45:59
author: zhanggeng
categories: JavaScript
---

# 如何定义一个JS函数

1. 第一种定义方式：

	```
	function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
	}
	```
	
	上述的函数定义中：
	
	*  `function`指出这是一个函数定义；
	*  `abs`是函数的名称；
	*  `(x)`括号内列出函数的参数，多个参数以`,`分割；
	*  `{ ... }`之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句

2. 第二种定义方式：

	```
	var abs = function (x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
	};
	```

在上述的定义中，`function(x){...}`是一个匿名函数，它没有函数名。这个匿名函数赋值给了变量abs，所以，通过变量`abs`就可以调用该函数。

> *Notice*: 第二种方式定义函数，需要在函数末尾加一个`;`，表示赋值语句结束。


# 如何调用JS函数：

按照顺序传入参数即可完成函数的调用：

```
abs(10); // 返回10
abs(-9); // 返回9
```

函数传入的参数比定义的参数多会怎样呢？

> JS允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没问题，虽然函数内部并不需要这些参数。

函数传入的参数比定义的参数少会怎样呢？

> 少也没问题，比如abs()，将会返回NaN，此时abs(x)函数的参数 x 将受到undefined，计算结果为NaN 。

为了避免受到`undefined`，可以对参数进行检查：

```
function abs(x){
	if(typeof x!== 'number'){
		throw 'Not a number';
	}
	
	if(x >= 0){
		return x;
	}else{
		return -x;
	}
}
```

> 函数参数，这个和Java真是有很大的区别，在Java中，如何传入的参数个数，数据类型任意一个不一样，编译都不会通过，JS竟然还可以这样玩儿，牛逼；


# arguments

JS中的关键字：`arguments`，只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array:

```
function foo(x) {
    alert(x); // 10
    for (var i=0; i<arguments.length; i++) {
        alert(arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
```

利用arguments，你可以获得调用者传入的所有参数，实际情况中，arguments最常用语判断传入参数的个数。如下代码所示：

```
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
```

# reset参数

由于JS函数允许接收任意个参数，我们就不得不用`arguments`来获取所有参数，如下代码所示：

```
function foo(a, b) {
    var i, rest = [];
    if (arguments.length > 2) {
        for (i = 2; i<arguments.length; i++) {
            rest.push(arguments[i]);
        }
    }
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}
```

在ES6标准中引入了rest参数，上面的函数可以改写为：

```
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```

> 1. rest参数只能写在最后，前面用`...`标识。从运行结果可以看到，传入参数先绑定a , b ，多余的参数以数组形式交给变量rest,所以，不再需要arguments我们就可以获取全部参数了。
> 2. 如果传入的参数连正常定义参数都没填满，rest参数会接收一个空数组。

# 小心你的return语句

JS引擎会在行末自动添加分号，这会让你栽到return语句的一个大坑：

such as:

```
function foo() {
    return
        { name: 'foo' };
}

foo(); // undefined
```
上面的代码在JS引擎执行后，变成了下面的样子：

```
function foo() {
    return; // 自动添加了分号，相当于return undefined;
        { name: 'foo' }; // 这行语句已经没法执行到了
}
```

这就是个大坑。


# 变量作用域

* 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量
* 如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响
* 嵌套函数，内部函数可以访问外部函数定义的变量，反过来则不行
* 内部函数和外部函数的变量名重名，则内部函数的变量将“屏蔽”外部函数的变量


#### 变量提升

JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：

```
'use strict';

function foo() {
    var x = 'Hello, ' + y;
    alert(x);
    var y = 'Bob';
}

foo();
```

JS引擎编译后，代码其实是这样的：

```
function foo() {
    var y; // 提升变量y的申明
    var x = 'Hello, ' + y;
    alert(x);
    y = 'Bob';
}
```

*请绕坑：* 对于JS的这一诡异特性，请严格遵守“在函数内部首先申明所有变量”。

#### 全局作用域

不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：

```
'use strict';

var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript'
```

因此，直接访问全局变量course和访问window.course是完全一样的。

#### 名字空间

全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。

减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。

```
// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = 'myapp';
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return 'foo';
};
```

把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。

#### 局部作用域

由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的:

```
'use strict';

function foo() {
    for (var i=0; i<100; i++) {
        //
    }
    i += 100; // 仍然可以引用变量i
}
```

ES6引入了新的关键字let,用来解决块级作用域，用let替代var可以申明一个块级作用域的变量：

```
'use strict';

function foo() {
    var sum = 0;
    for (let i=0; i<100; i++) {
        sum += i;
    }
    i += 1; // SyntaxError
}
```

#### 常量

之前申明一个常量，通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：

```
var PI = 3.14;
```

ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：

```
'use strict';

const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

# 方法

在一个对象中绑定函数，称为这个对象的方法。

```
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
```

#### this

在上面的代码中有个`this`，这个this是干嘛的呢？

在一个方法内部，this始终指向当前对象，也就是xiaoming这个变量。所以，this.birth 就可以拿到xiaoming的birth属性。

拆开来写：

```
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```

单独调用函数：getAge()怎么返回了NaN?

*请绕坑：*

JS函数内部如果调用了this，那么这个this指向谁呢？

答案：视情况而定！

* 如果以对象的方法形式调用，比如xiaoming.age()，该函数的`this`指向被调用的对象，也就是`xiaoming`，这是符合我们预期的。
* 如果单独调用函数，比如getAge()，此时，该函数的`this`指向全局对象，也就是`window`。

要保证this指向正确，必须用obj.xxx()的形式调用！

ECMA决定，在strict模式家让函数的this指向undefined，因此，在strict模式下，你会得到一个错误：

> // Uncaught TypeError: Cannot read property 'birth' of undefined

那么该如何修复呢？

```
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // 25

```

#### apply()

apply方法是函数本身具有的，它可以指定函数的this指向哪个对象。它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array,表示函数本身的参数。

用apply修复getAge()调用：

```
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

另一个与apply（）类似的方法是call()，唯一的区别是：

* apply()把参数打包成Array再传入；
* call()把参数按顺序传入；

下面分别用apply()和call()实现调用Math.max(3, 4, 5):

```
Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5
```

对普通函数调用，我们通常把this绑定为null。

#### 装饰器

apply()，可以动态改变函数的行为。

JS的所有对象都是动态的，即使是内置的函数，我们有可以重新指向新的函数。

假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：

```
var count = 0;
var oldParseInt = parseInt; // 保存原函数

window.parseInt = function () {
    count += 1;
    return oldParseInt.apply(null, arguments); // 调用原函数
};

// 测试:
parseInt('10');
parseInt('20');
parseInt('30');
count; // 3
```

# 高阶函数

什么是高阶函数呢？

一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。

一个简单的高阶函数：

```
function add(x, y, f) {
    return f(x) + f(y);
}

add(-4 , 5  , Math.abs)
```

编写高阶函数，就是让函数的参数能够接收别的参数。







---
layout: post
title:  "Node.js"
date:   2016-08-16 08:45:59
author: zhanggeng
categories: JavaScript
---

# 模块

在Node环境中，一个.js文件就称之为一个模块。

使用模块的好处：

1. 提高了代码的可维护性
2. 编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用
3. 使用模块还可以避免函数名和变量名冲突

导出模块时用：

```
module.exports = xxx
```

# 基本模块

## global

JS有且仅有一个全局对象，在浏览器中，叫window对象。在Node.js环境中，这个唯一的对象叫global，这个对象的属性和方法和浏览器环境的window也不同。

在命令行中输入node,进入Node.js交互环境，可以直接输入：

```
global.console
```

可以看到信息：

```
Console {
  log: [Function: bound ],
  info: [Function: bound ],
  warn: [Function: bound ],
  error: [Function: bound ],
  dir: [Function: bound ],
  time: [Function: bound ],
  timeEnd: [Function: bound ],
  trace: [Function: bound trace],
  assert: [Function: bound ],
  Console: [Function: Console] }
```

## process

process是Node.js提供的一个对象，代表当前Node.js进程。通过process对象可以拿到许多有用信息：

```
> process === global.process;
true
> process.version;
'v5.2.0'
> process.platform;
'darwin'
> process.arch;
'x64'
> process.cwd(); //返回当前工作目录
'/Users/michael'
> process.chdir('/private/tmp'); // 切换当前工作目录
undefined
> process.cwd();
'/private/tmp'
```

JS 程序是由时间驱动执行的单线程模型，Node.js不断执行响应事件的JS函数，知道没有任何响应事件的函数可以执行时，Node.js就退出。

如果我们想要在下一次事件响应中执行代码，可以调用process.nextTick():

```
// process.nextTick()将在下一轮事件循环中调用:
process.nextTick(function () {
    console.log('nextTick callback!');
});
console.log('nextTick was set!');
```

## 判断JS执行环境

有很多JS代码既能在浏览器中执行，也能在Node环境执行，有些时候，程序本身需要判断自己到底是在什么环境下执行，常用的方式是根绝浏览器和Node环境提供的全局变量名称来判断：

```
if (typeof(window) === 'undefined') {
    console.log('node.js');
} else {
    console.log('browser');
}
```

## fs

Node.js内置的fs模块就是文件系统模块，负责读写文件。它同时提供了异步和同步的方法。

### 异步读取

Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。

```
if (err) {
    // 出错了
} else {
    // 正常
}
```
异步读取时，传入回调函数两个参数，

正常读取时：
> err: null；
> data: 读取到的String.

读取发生错误时：

> err:参数代表一个错误对象；
> data: 为undefined;

### 同步读取文件

同步读取的函数：多了一个sync后缀，并且不接受回调函数，函数直接返回结果。

同步读取文件发生错误，则需要用try...catch捕获该错误：

```
try {
    var data = fs.readFileSync('sample.txt', 'utf-8');
    console.log(data);
} catch (err) {
    // 出错了
}
```

### 写文件

将数据写入文件是通过fs.writeFile()实现的：

writeFile()的参数一次为文件名、数据和回调函数。

```
'use strict';

var fs = require('fs');

var data = 'Hello, Node.js';
fs.writeFile('output.txt', data, function (err) {
    if (err) {
        console.log(err);
    } else {
        console.log('ok.');
    }
});
```

writeFile的同步方法，writeFileSync():

```
'use strict';

var fs = require('fs');

var data = 'Hello, Node.js';
fs.writeFileSync('output.txt', data);
```

### stat

fs.stat()——>获取文件大小、创建时间等信息，它返回一个Stat对象，包含文件或目录的详细信息：

```
'use strict';

var fs = require('fs');

fs.stat('/Users/zhanggeng/Documents/js_Project', function (err, stat) {
    if (err) {
        console.log(err);
    } else {
        // 是否是文件:
        console.log('isFile: ' + stat.isFile());
        // 是否是目录:
        console.log('isDirectory: ' + stat.isDirectory());
        if (stat.isFile()) {
            // 文件大小:
            console.log('size: ' + stat.size);
            // 创建时间, Date对象:
            console.log('birth time: ' + stat.birthtime);
            // 修改时间, Date对象:
            console.log('modified time: ' + stat.mtime);
        }

        if(stat.isDirectory){
            console.log('size=====' + stat.size);

            console.log('birthtime====' + stat.birthtime);


            console.log('modifiedtime=====' + stat.mtime);
        }
    }
});
```

### 异步还是同步

到底在什么时候用异步方法还是同步方法呢？

1. 绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须用异步代码，否则，同步代码在执行时期，服务器将停止响应，因为JS只有一个执行线程。
2. 服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。

# stream

Node.js提供的在服务器端支持“流”这种数据结构的模块。

stdin： 标准输入流；
stdout: 标准输出流；

Node.js中，流是一个对象：

> data 事件表示流的数据已经可以读取了；
> end 事件表示这个流已经到末尾了，没有数据可以读取了；
> error：事件表示出错了。

data事件可能会有多次，每次传递的chunk是流的一部分数据；

要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束。

所有可以读取数据的流都继承自stream.Readable,所有可以写入的流都继承自stream.Writable.


## pipe

像两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫： pipe.

Node.js中，Readable流有一个pipe()方法，用来干这件事的。

```
'use strict';

var fs = require('fs');

var rs = fs.createReadStream('sample.txt');
var ws = fs.createWriteStream('copied.txt');

rs.pipe(ws);
```

默认，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数：

```
readable.pipe(writable, { end: false });
```


# http


### HTTP 服务器

应用程序并不直接和HTTP协议打交道，而是操作Http模块提供的request和response对象。

request： 对象封装了HTTP对象，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息；

response: 对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。

### 文件服务器

我们可以设定一个目录，然后让Web程序变为一个文件服务器。实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。


解析URL需要用到Node.js提供的url模块，通过parse()将一个字符串解析为一个Url对象：

```
'use strict';

var url = require('url');

console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash'));
```

# crypto

crypto模块的目的是为了提供通用的加密和哈希算法。这些模块由C/C++实现算法后，通过cypto暴露为JS接口。

* MD5 和 SHA1
* Hmac
* AES
* Diffie-Hellman


